sklearn style


Harness:

- init(graph)

- fit(source, hyperparams, n_iter, print_freq, etc)
    interface directly with the graph; need to write different harnesses per
        problem



Graph

- init(canvas, edges, outputs, contraints, updates)

- compile()
    build internal theano function

- call(**kwargs)
    must match the compiled function
    buffer inputs if too large?
    after every call, execute constraints




Order

Training
- build nodes (from python or json)
- build graphs (from python or json)
- build harnesses (from python)
- build sources (from python)

Transform
- build nodes (from python or json)
- build graphs (from python or json)
- build transform (from python)


Source: Either a File or dictionary of Entities

Queue:
* batch_size either goes to init or next

- next():
    unpacks a batch of entities by the names; output entities need not be the
    same as those contained in the source?


Buglist
-------
- Serialization and restoration
- Instantiating multiple Graphs with the same nodes breaks some stuff pretty
    hard right now.
- Parameters are lacking a decent initialization strategy, and right now it's
    deathly for the Likelihood layer
- Also, rename the Likelihood layer to "Softmax", or let Affine take softmax
    as an activation (and stop worrying about all this junk)
